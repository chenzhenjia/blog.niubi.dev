<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>陈</title><link>https://blog.niubi.dev/</link><description>陈asdasdasd</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 24 Oct 2019 10:24:53 +0800</lastBuildDate><atom:link href="https://blog.niubi.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>SpringBoot配置VueJs或者React的history路由</title><link>https://blog.niubi.dev/posts/springboot%E9%85%8D%E7%BD%AEvuejs%E6%88%96%E8%80%85react%E7%9A%84history%E8%B7%AF%E7%94%B1/</link><pubDate>Thu, 24 Oct 2019 10:24:53 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/springboot%E9%85%8D%E7%BD%AEvuejs%E6%88%96%E8%80%85react%E7%9A%84history%E8%B7%AF%E7%94%B1/</guid><description><![CDATA[一般在配置前端的文件夹的时候都会指定一个路径，如果你想使用根路径我这种方法不支持根路径，请使用另外一种支持根路径的配置方法。
配置 比如把前端放在 h5 路径下面
把前端打包的文件放在resource/META-INF/h5 目录
修改Spring Boot WebMvc的配置
@Configuration public class WebMvcConfiguration implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&#34;/h5/**&#34;) .addResourceLocations(&#34;classpath:/META-INF/h5/&#34;); } @Override public void addViewControllers(ViewControllerRegistry registry) { // 配置如果用户访问的是根目录直接重定向掉h5页面 registry.addRedirectViewController(&#34;/&#34;, &#34;h5&#34;); // 配置用户如果访问h5路径但是没有带index.html 转发到 /h5/index.html 路径 registry.addViewController(&#34;/h5&#34;) .setViewName(&#34;forward:/h5/index.html&#34;); registry.addViewController(&#34;/h5/&#34;) .setViewName(&#34;forward:/h5/index.html&#34;); // 一下是为了给前端 history路由的一些配置 registry.addViewController(&#34;/h5/{spring:\\w+}&#34;) .setViewName(&#34;forward:/h5/index.html&#34;); registry.addViewController(&#34;/h5/**/{spring:\\w+}&#34;) .setViewName(&#34;forward/h5/index.html&#34;); registry.addViewController(&#34;/h5/{spring:\\w+}/**{spring:?!(\\.js|\\.css)$}&#34;) .setViewName(&#34;forward:/h5/index.html&#34;); } } ]]></description></item><item><title>在 centos 上搭建k3s 集群</title><link>https://blog.niubi.dev/posts/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAk3s%E9%9B%86%E7%BE%A4/</link><pubDate>Sat, 24 Aug 2019 15:38:25 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAk3s%E9%9B%86%E7%BE%A4/</guid><description><![CDATA[介绍 k3s k3s 是Rancher Labs（以下简称Rancher）宣布推出轻量级Kubernetes发行版K3s（已开源），这款产品专为在资源有限的环境中运行Kubernetes的研发和运维人员设计。Rancher此次发布的K3s项目，将满足在边缘计算环境中运行在x86、ARM64和ARMv7处理器上的小型、易于管理的Kubernetes集群日益增长的需求。
开始安装 安装 docker 官方文档 这里推荐使用官方的脚本一键安装
curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 如果你想使用 k3s 默认的 contanerd 容器可以跳过，但是由于我对 contanerd 不熟悉所以我在这里使用的是 docker
安装 k3s server
安装 k3s server 有几种方式，由于 k3s 的执行文件是是放在 github上的，但是在中国由于网速不好可能会导致下载不下来，所以可以先使用其它工具下载可执行文件然后上传到服务器上的 /usr/local/bin 目录下，然后执行 chmod 0755 /usr/local/bin/k3s 命令给与执行权限
直接下载安装:
curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=&#34;server --no-deploy traefik --docker&#34; sh -s - 自己下载安装:
curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=&#34;server --no-deploy traefik --docker&#34; INSTALL_K3S_BIN_DIR=&#34;/usr/local/bin&#34; INSTALL_K3S_SKIP_DOWNLOAD=true sh -s - 参数说明: INSTALL_K3S_EXEC k3s 启动的参数 &ndash;no-deploy traefik 是说不需要部署 traefik ingress，_&ndash;docker_是说使用 docker 容器 INSTALL_K3S_BIN _DIRk3s 可执行文件的目录 INSTALL_K3S_SKIP _DOWNLOAD true 跳过下载k3s 可执行文件]]></description></item><item><title>Golang在Windows上同时编译64位和32位可执行程序</title><link>https://blog.niubi.dev/posts/golang%E5%9C%A8windows%E4%B8%8A%E5%90%8C%E6%97%B6%E7%BC%96%E8%AF%9164%E4%BD%8D%E5%92%8C32%E4%BD%8D%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</link><pubDate>Fri, 02 Nov 2018 18:38:39 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/golang%E5%9C%A8windows%E4%B8%8A%E5%90%8C%E6%97%B6%E7%BC%96%E8%AF%9164%E4%BD%8D%E5%92%8C32%E4%BD%8D%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</guid><description>Golang 在 Windows 上同时编译64位和32位可执行程序 需要在windows上同时编译需要64位的系统，32位只能编译32位的可执行程序。
编译32位 GOOS=windows GOARCH=386 go build main.go 编译64位 GOOS=windows GOARCH=amd64 go build main.go 遇到的问题 由于在项目中用到了sqlite所以在编译的时候报 exec: &amp;ldquo;gcc&amp;rdquo;: executable file not found in %PATH%，这是因为在windows上缺少 gcc,所以在windows 上需要安装 MinGW。
下载 MinGW 进入下载页面
下载 MinGW64，注意请选择 _x86_64-posix-seh MinGW64 8.1.0 下载地址
下载 MinGW32 MinGW32 8.1.0 下载地址
解压 MinGW32和MinGW64 注意需要解压到不同地方，可以平级但是千万不要在同一个目录
编译 在编译之前先设置 MinGW 的环境变量，因为是一次性的所以直接用命令行来设置
64位编译 请注意_C:MinGW64bin_ 应该改为你的64位MinGW路径 set PATH=C:\MinGW64\bin;%PATH% GOOS=windows GOARCH=386 go build main.go * 32位编译 请注意_C:MinGW32bin_ 应该改为你的32位MinGW路径 ```bash set PATH=C:\MinGW32\bin;%PATH% GOOS=windows GOARCH=amd64 go build main.</description></item><item><title>Spring MVC 自定义静态资源下载</title><link>https://blog.niubi.dev/posts/spring-mvc-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/</link><pubDate>Tue, 04 Sep 2018 14:18:53 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/spring-mvc-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/</guid><description><![CDATA[在 Spring MVC 中上传文件后把文件保存在本地，但是数据库保存了一份路径，所有需要实现下载文件，网上的教程一般都是自己写一个Controller 去下载，但是我这里直接使用Spring MVC的 ResourceHttpRequestHandler 实现动态下载静态资源，只需一点点代码然后加一段配置就可以实现下载附件功能。
第一步 自定义一个Handler，并重写 ResourceHttpRequestHandler 的 processPath 方法。
@Slf4j public class CustomResourceHttpRequestHandler extends ResourceHttpRequestHandler { private final UploadRepository uploadRepository; public CustomResourceHttpRequestHandler(UploadRepository uploadRepository) { this.uploadRepository = uploadRepository; } // 重写该方法实现动态获取文件路径，而不是直接获取本地文件的路径 @Override protected String processPath(String path) { Optional&lt;Upload&gt; uploadOption = uploadRepository.findById(path); return uploadOption.map(Upload::getPath) .orElseGet(() -&gt; { log.warn(&#34;文件获取path不存在。path={}&#34;, path); return null; }); } } 第二部配置 在 Spring Boot 中添加一下配置，注意LocationValues 的路径，必须以 / 结尾，访问本地文件必须有 file: ，不然会访问不到，报404
@Bean public ResourceHttpRequestHandler customResourceHttpRequestHandler(UploadRepository uploadRepository) { ResourceHttpRequestHandler requestHandler = new CustomResourceHttpRequestHandler(uploadRepository); requestHandler.]]></description></item><item><title>优雅开启和关闭Spring Cloud项目</title><link>https://blog.niubi.dev/posts/%E4%BC%98%E9%9B%85%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%ADspringcloud%E9%A1%B9%E7%9B%AE/</link><pubDate>Sat, 18 Aug 2018 12:59:08 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/%E4%BC%98%E9%9B%85%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%ADspringcloud%E9%A1%B9%E7%9B%AE/</guid><description><![CDATA[第一种方式,使用脚本(不推荐) 使用命令行开启和关闭，直接 kill 掉Spring boot 进程，这样会导致Spring Cloud 项目不会去 注册中心把自己销毁掉，明明项目已经关闭，但是注册中心还是显示在线，而且这样还会有一个弊端，如果需 要监听Spring Boot 项目的生命周期钩子，比如项目启动和关闭，也会监听不到。 /home/dev/app.sh
#!/bin/bash APP_NAME=$2 #使用说明，用来提示输入参数 usage() { echo &#34;Usage: sh 执行脚本.sh [start|stop|restart|status]&#34; exit 1 } #检查程序是否在运行 is_exist(){ count=`ps -ef |grep java|grep $APP_NAME|grep -v grep|wc -l` #如果不存在返回1，存在返回0 if [ $count == 0 ]; then return 1 else return 0 fi } #启动方法 start(){ is_exist if [ $? -eq &#34;0&#34; ]; then echo &#34;${APP_NAME} is already running. pid=${pid} .&#34; else SHELL_FOLDER=$(cd &#34;$(dirname &#34;$0&#34;)&#34;;pwd) JAR_PATH=&#34;$SHELL_FOLDER/.]]></description></item><item><title>expect 的用法</title><link>https://blog.niubi.dev/posts/expect%E7%9A%84%E7%94%A8%E6%B3%95/</link><pubDate>Fri, 17 Aug 2018 11:52:44 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/expect%E7%9A%84%E7%94%A8%E6%B3%95/</guid><description><![CDATA[!/usr/bin/expect 告诉操作系统脚本里的代码使用那一个shell来执行。
注意：这段代码必须在第一行。
set timeout 设置超时时间，计时单位是：秒 ，timeout -1 为永不超时。
spawn spawn是进入expect环境后才可以执行的expect内部命令，如果没有装expect或者直接在默认的SHELL下执行是找不到spawn命令的。所以不要用 which spawn 之类的命令去找spawn命令。
它主要的功能是给ssh运行进程加个壳，用来传递交互指令。
expect &ldquo;str&rdquo; 这个命令的意思是判断上次输出结果里是否包含“str”的字符串，如果有则立即返回，否则就等待一段时间后返回，这里等待时长就是 set timeout send &quot;&quot; 这里就是执行交互动作，
命令字符串结尾别忘记加上“\r”，如果出现异常等待的状态可以核查一下。
interact 执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。如果你只是登录过去执行
$argv 参数数组 expect脚本可以接受从bash传递过来的参数.可以使用[lindex $argv n]获得，n从0开始，分别表示第一个,第二个,第三个&hellip;.参数
示例 expect 调用 ssh 密码登陆 #!/usr/bin/expect set timeout 5 set password &#34;1234&#34; spawn ssh root@127.1.1 expect { &#34;yes/no&#34; { send &#34;yes\r&#34;; exp_continue } &#34;Password:&#34; { send &#34;$password\r&#34; } } interact ]]></description></item><item><title>Linux 各个目录的说明</title><link>https://blog.niubi.dev/posts/linux%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E8%AF%B4%E6%98%8E/</link><pubDate>Fri, 17 Aug 2018 11:52:00 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/linux%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E8%AF%B4%E6%98%8E/</guid><description>根文件系统 /bin 这一目录中存放了供所有用户使用的完成基本维护任务的命令。其中bin是binary的缩写，表示二进制文件，通常为可执行文件。 一些常用的系统命令，如cp、ls等保存在该目录中。
/boot 这里存放的是启动Linux时使用的一些核心文件。如操作系统内核、引导程序Grub等。
/dev 在此目录中包含所有的系统设备文件。从此目录可以访问各种系统设备。如CD-ROM，磁盘驱动器，调制解调器和内存等。 在该目录中还包含有各种实用功能，如用于创建设备文件的MAKEDEV。
/etc 该目录中包含系统和应用软件的配置文件。
/etc/passwd 该目录中包含了系统中的用户描述信息，每行记录一个用户的信息。
/home 存储普通用户的个人文件。每个用户的主目录均在/home下以自己的用户名命名。
/lib 这个目录里存放着系统最基本的共享链接库和内核模块。共享链接库在功能上类似于Windows里的.dll文件。
/lib64 64位系统有这个文件夹，64位程序的库。
/lost+found 这并不是Linux目录结构的组成部分，而是ext3文件系统用于保存丢失文件的地方。 不恰当的关机操作和磁盘错误均会导致文件丢失，这意味着这些被标注为“在使用”，但却并未列于磁盘上的数据结构上。 正常情况下，引导进程会运行fsck程序，该程序能发现这些文件。除了“/”分区上的这个目录外，在每个分区上均有一个lost+found目录。
/media 可移动设备的挂载点，当前的操作系统通常会把U盘等设备自动挂载到该文件夹下。
/mnt 临时用于挂载文件系统的地方。一般情况下这个目录是空的，而在我们将要挂载分区时在这个目录下建立目录，再将我们将要访问的设备挂载在这个目录上，这样我们就可访问文件了。（注意在GNOME中，只有挂载到/media的文件夹才会显示在“计算机”中，挂载到/mnt不会做为特殊设备显示，详见自动挂载分区）
/opt 多数第三方软件默认安装到此位置，如Adobe Reader、google-earth等。并不是每个系统都会创建这个目录。
/proc 它是存在于内存中的虚拟文件系统。里面保存了内核和进程的状态信息。多为文本文件，可以直接查看。如/proc/cpuinfo保存了有关CPU的信息。
/root 这是根用户的主目录。与保留给个人用户的/home下的目录很相似，该目录中还包含仅与根用户有关的条目。
/sbin 供超级用户使用的可执行文件，里面多是系统管理命令，如fsck, reboot, shutdown, ifconfig等。
/tmp 该目录用以保存临时文件。该目录具有Sticky特殊权限，所有用户都可以在这个目录中创建、编辑文件。但只有文件拥有者才能删除文件。为了加快临时文件的访问速度，有的实现把/tmp放在内存中。
/usr 静态的用户级应用程序等，见下。
/var 动态的程序数据等，见下文。
/usr目录结构 /usr通常是一个庞大的文件夹，其下的目录结构与根目录相似，但根目录中的文件多是系统级的文件，而/usr中是用户级的文件，一般与具体的系统无关。 应注意，程序的配置文件、动态的数据文件等都不会存放到/usr，所以除了安装、卸载软件外，一般无需修改/usr中的内容。说在系统正常运行时，/usr甚至可以被只读挂载。由于这一特性，/usr常被划分在单独的分区，甚至有时多台计算机可以共享一个/usr。
提示： usr最早是user的缩写，/usr的作用与现在的/home相同。而目前其通常被认为是 User System Resources 的缩写，其中通常是用户级的软件等，与存放系统级文件的根目录形成对比。
/usr/bin 多数日常应用程序存放的位置。如果/usr被放在单独的分区中，Linux的单用户模式不能访问/usr/bin，所以对系统至关重要的程序不应放在此文件夹中。
/usr/include 存放C/C++头文件的目录
/usr/lib 系统的库文件
/usr/local 新装的系统中这个文件夹是空的，可以用于存放个人安装的软件。安装了本地软件的/usr/local里的目录结构与/usr相似
/usr/sbin 在单用户模式中不用的系统管理程序，如apache2等。
/usr/share 与架构无关的数据。多数软件安装在此。
/usr/X11R6 该目录用于保存运行X-Window所需的所有文件。该目录中还包含用于运行GUI要的配置文件和二进制文件。 ###/usr/src 源代码</description></item><item><title>Ubuntu16.04.5 安装 Docker</title><link>https://blog.niubi.dev/posts/ubuntu16.04.5%E5%AE%89%E8%A3%85docker/</link><pubDate>Fri, 17 Aug 2018 09:42:29 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/ubuntu16.04.5%E5%AE%89%E8%A3%85docker/</guid><description><![CDATA[使用 apt-get 安装 卸载掉旧版本 命令:
sudo apt remove docker docker-engine docker.io 安装 更新软件包 sudo apt update 添加使用 HTTPS 传输的软件包以及 CA 证书 sudo apt install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加Docker的官方GPG密钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 验证秘钥
sudo apt-key fingerprint 0EBFCD88 查看是否能找到 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。
添加 docker 源 sudo add-apt-repository \ &#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&#34; &amp;&amp; sudo apt update 安装 sudo apt install docker-ce 启动 docker sudo systemctl enable docker sudo systemctl start docker ]]></description></item><item><title>mysql允许用户远程连接的方式</title><link>https://blog.niubi.dev/posts/mysql%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F/</link><pubDate>Fri, 10 Aug 2018 22:26:17 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/mysql%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F/</guid><description><![CDATA[mysql允许用户远程连接的方式。 第一步（修改配置文件） vim /etc/mysql/my.cnf 找到 bind-address = 127.0.0.1
注释掉这行，如：#bind-address = 127.0.0.1
或者改为： bind-address = 0.0.0.0
允许任意IP访问；
或者自己指定一个IP地址。
重启 MySQL：sudo /etc/init.d/mysql restart
第二步（授权用户能进行远程连接）
grant all privileges on *.* to root@&quot;%&quot; identified by &quot;password&quot; with grant option; flush privileges;
第一行命令解释如下，. ：第一个代表数据库名；第二个代表表名。这里的意思是所有数据库里的所有表都授权给用户。root：授予root账号。 “%”：表示授权的用户IP可以指定，这里代表任意的IP地址都能访问MySQL数据库。“password”：分配账号对应的密码，这里密码自己替换成 你的mysql root帐号密码。
第二行命令是刷新权限信息，也即是让我们所作的设置马上生效。]]></description></item><item><title>k8s 安装ingress-nginx后代理kubernetes-dashboard</title><link>https://blog.niubi.dev/posts/k8s%E5%AE%89%E8%A3%85ingress-nginx%E5%90%8E%E4%BB%A3%E7%90%86kubernetes-dashboard/</link><pubDate>Mon, 30 Apr 2018 19:06:43 +0800</pubDate><author>陈</author><guid>https://blog.niubi.dev/posts/k8s%E5%AE%89%E8%A3%85ingress-nginx%E5%90%8E%E4%BB%A3%E7%90%86kubernetes-dashboard/</guid><description><![CDATA[准备 k8s 集群，版本为1.9.5 kubernetes-dashboard 为 v1.8.3 安装 kubernetes-dashboard 直接使用官方的命令安装
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml 暴露端口，以便访问，用完之后改回
kubectl -n kube-system edit service kubernetes-dashboard 按 i 进入插入模式 修改 type 值 ClusterIP 为NodePort 然后按 esc ，再按 x 回车保存
查看端口
kubectl -n kube-system get service kubernetes-dashboard NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes-dashboard 10.100.124.90 &lt;nodes&gt; 443:31707/TCP 21h 其中 31707就是外部可以访问的 ip
创建管理员 // admin-role.yaml
kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: admin annotations: rbac.authorization.kubernetes.io/autoupdate: &#34;true&#34; roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.]]></description></item></channel></rss>